import i from"path";const m=/^\.{1,2}\//,g=/\*/g,p=(t,r)=>{const n=t.match(g);if(n&&n.length>1)throw new Error(r)};function P(t){if(t.includes("*")){const[r,n]=t.split("*");return{prefix:r,suffix:n}}return t}const x=({prefix:t,suffix:r},n)=>n.startsWith(t)&&n.endsWith(r);function d(t,r,n){return Object.entries(t).map(([a,c])=>(p(a,`Pattern '${a}' can have at most one '*' character.`),{pattern:P(a),substitutions:c.map(s=>{if(p(s,`Substitution '${s}' in pattern '${a}' can have at most one '*' character.`),!s.startsWith("./")&&!r)throw new Error("Non-relative paths are not allowed when 'baseUrl' is not set. Did you forget a leading './'?");return i.join(n,s)})}))}function v(t){if(!t.config.compilerOptions)return null;const{baseUrl:r,paths:n}=t.config.compilerOptions;if(!r&&!n)return null;const a=i.resolve(i.dirname(t.path),r||"."),c=n?d(n,r,a):[];return function(o){if(m.test(o))return[];const l=[];for(const e of c){if(e.pattern===o)return e.substitutions;typeof e.pattern!="string"&&l.push(e)}let h,u=-1;for(const e of l)x(e.pattern,o)&&e.pattern.prefix.length>u&&(u=e.pattern.prefix.length,h=e);if(!h)return r?[i.join(a,o)]:[];const f=o.slice(h.pattern.prefix.length,o.length-h.pattern.suffix.length);return h.substitutions.map(e=>e.replace("*",f))}}export{v as createPathsMatcher};
